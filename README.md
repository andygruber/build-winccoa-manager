# WinCC OA C++ API Manager Builder

This GitHub repository provides a ready-to-use GitHub Action to build C++ API managers for WinCC OA.
It is designed to lower the entry barrier for developers and allow easy building, unit testing, and packaging of WinCC OA API managers for multiple combinations of OS and WinCC OA versions using a single C++ source code.

## Features

- **Ease of Use**: Set up with minimal configuration required.
- **Multiple OS and WinCC OA Version Support**: Build your API managers for various combinations of operating systems and WinCC OA versions.
- **C++ Package Manager Support**: Conan package manager is supported out of the box for managing C++ dependencies.
- **Automated Testing and Packaging**: Includes support for unit testing and packaging of your API managers.
- **Debug files available**: PDB and unstripped files are kept beside the build artifacts.
- **Caching Support**: Conan packages and extracted Windows API files are cached automatically

## Getting Started

### Prerequisites

- A GitHub account
- Basic knowledge of C++ and CMake
- Familiarity with GitHub Actions
- Access to WinCC OA API docker images (Linux) and WinCC OA MSI packages (Windows)

### Fork the Repository

To get started, fork this repository to your own GitHub account. This will be the home for your C++ CMake project for building WinCC OA API managers.

### Initial general configuration

The default configuration is saved in `pipeline/createMatrix/mergekeys.yml`.

In this file the used Docker images and the locations for the WinCC OA MSI packages are stored.
As those prerequisites are not available publicly, those need to be created manually and defined here.

#### Linux

Linux builds rely on Docker images.
The API images generated by the public repo [https://github.com/andygruber/build-winccoa-docker-image](https://github.com/andygruber/build-winccoa-docker-image) are compatible.
E.g.: 
```
  container_image: 'agruberetm/winccoa:v3.19.9-api'
```

Also provide the following credentials in the GitHub secrets:
- DOCKERHUB_USER
- DOCKERHUB_PASSWORD

#### Windows

Windows is a lot more complicated. This is just an example implementation, replace it with something more fitting your environment.

- On a machine with WinCC OA >= 3.19 installed, go to `C:\ProgramData\Package Cache` and search for `Base.msi` and `APIcpp.msi`.
- Provide those files publicly shared in OneDrive (one link per file).
- In addition take `C:\Windows\System32\WibuCm64.dll`, zip it to `NODEPLOY_CODEMETER.zip` and provide it as OneDrive link as well.
- E.g.:
    ```
    directurl_base: 'https://1drv.ms/u/s!some_public_share_url1'
    directurl_apicpp: 'https://1drv.ms/u/s!some_public_share_url2'
    directurl_codemeter: 'https://1drv.ms/u/s!some_public_share_url3'
    ```

### Add Your C++ CMake Project

Place your C++ source code anywhere in the repository alongside a `CMakeLists.txt` file.
This is where you'll define your project and its dependencies.

### Configuration

Create a `build-config.yml` file in your repository alongside the `CMakeLists.txt`.
This file specifies the build configurations for different OS and WinCC OA versions.
Here's an example based on the provided demo driver in the `demoDrv`directory:

```yaml
demoDriver:
  configuration:
    win_3_19_relwithdebinfo:
      <<: *_win_3_19_relwithdebinfo
    win_3_20_relwithdebinfo:
      <<: *_win_3_20_relwithdebinfo
    debian_3_20_relwithdebinfo:
      <<: *_debian_3_20_relwithdebinfo
    debian_3_19_relwithdebinfo:
      <<: *_debian_3_19_relwithdebinfo
```

For C++ package management, create a `conanfile.txt` or `conanfile.py` file alongside your `CMakeLists.txt`.

### Utilize Packaging and Testing

To use unit testing and/or packaging, include the necessary CMake files for packaging and testing as follows:
```cmake
project(demoDrv
  VERSION 0.1.0
)
# make sure to place the include commands after the project
# command specifying the project name and version
include(../cmake/packaging.cmake)
include(../cmake/testing.cmake)
```

These includes will enable the GitHub Action pipeline to perform automated testing and packaging of your project.

Testing also requires the [googletest](https://github.com/google/googletest) framework, just merge the following line into your `conanfile.py`:
```python
    def requirements(self):
        self.requires("gtest/1.14.0")
```

A full example of a `conanfile.py` can be found [here](BUILD.md#conan).

### Details about packaging

#### Key Features

- Automatically selects packaging format based on the target OS.
    - **Windows**: Packages are generated as ZIP files.
    - **Debian-based Linux**: Packages are generated as DEB files.
    - **Red Hat-based Linux**: Packages are generated as RPM files.
- Configures the CPACK_PACKAGING_INSTALL_PREFIX to ensure correct installation paths, with special handling for WinCC OA environments on Linux.

#### Customization

Beside the mentioned [Key features](#key-features) CPack default features are used.

For additional customization, such as including additional files in the package or changing package metadata, refer to the [CPack documentation](https://cmake.org/cmake/help/latest/module/CPack.html).

### How to Add a New Test

1. **Define Test Sources:**
List all source files associated with your test.
For a comprehensive test suite, you might separate your test sources from your main application sources.

2. **Use the `add_gtest_with_xml` Macro:**
This macro is used to compile the test sources into an executable, link it against Google Test and any necessary project libraries, and set up XML output for test results.
The basic syntax is:

   ```cmake
   add_gtest_with_xml(TARGET_NAME TARGET_LIBRARY TEST_SOURCES)
   ```

   - `TARGET_NAME`: A unique name for your test executable.
   - `TARGET_LIBRARY`: The library against which your test executable should be linked. This usually includes your project's main library.
   - `TEST_SOURCES`: The source files for your test.

3. **Example:**
For a hypothetical binary named `demoDrv` that tests functionality in `demoDrvLib`, you might write:

   ```cmake
   set(TEST_SOURCES demoDrvTest.cxx)
   add_gtest_with_xml(demoDrv demoDrvLib ${TEST_SOURCES})
   ```

4. **Integration with CMakeLists.txt:**
Add your test configuration to a `CMakeLists.txt` within your project's test directory.
If your project structure does not already include a test directory, create one as shown:

   ```cmake
   add_subdirectory(tests)
   ```

### Build Pipeline

The `build.yml` GitHub Action workflow file orchestrates the build process.
It prepares the build environment, installs necessary dependencies, and runs the build according to configurations specified in `build-config.yml`.
This process is triggered by push or pull request events to the main branch, or can be manually dispatched.

When running the build, certain directories are set automatically:
- **build directory:** is set set to `build/make`
- **install dir:** is set to `build/install` via `CMAKE_INSTALL_PREFIX` cache variable
- **packaging dir:** is set to `build/deploy` via `CPACK_OUTPUT_FILE_PREFIX` cache variable

**Note:** The automation searchs in these paths for the build artifacts, like test results or the generated binaries.
When doing modifications, please make sure those directories are still be set correctly by the automation.

## Local Build Environment Setup

For detailed instructions on setting up your local build environment, including configuring Conan and CMake for various build types, please see the [Build Environment Setup Guide](BUILD.md).
This guide provides step-by-step instructions to help you get started quickly and efficiently.

## Support

For any questions or support, consider opening an issue in the repository. Contributions to improve the build process or add new features are welcome.
